# src/backend/task_manager.py

from src.gui.components.directory_selector import DirectorySelector
from src.utils.interfaces.task_manager_interface import TaskManagerInterface
from src.backend.components.tsplib_management.tsp_catalog import TSPCatalog
from src.backend.components.tsplib_management.tsplib_parser import TSPLIBParser
from src.backend.components.threads.algorithm_threads import SimulatedAnnealingThread

# Import modules generated by pybind11
import compiled_binaries.SimulatedAnnealing as SimulatedAnnealing


class TaskManager(TaskManagerInterface):
    def __init__(self) -> None:
        """
        Initializes the TaskManager, setting up the TSPLIB parser, catalog, and directory selector.
        """
        # Initialize TSPLIBParser and TSPCatalog
        self.parser = TSPLIBParser()
        self.catalog = TSPCatalog("resources/metadata/optimal_results.json", self.parser)

        # Initialize DirectorySelector with injected TSPCatalog
        self.directory_selector = DirectorySelector(self.catalog)

        # Initialize algorithms, such as Simulated Annealing
        self.current_algorithm_thread = None

    def select_tsp_directory(self) -> None:
        """
        Invokes DirectorySelector to select a directory and automatically load TSP files.
        """
        self.directory_selector.select_directory_and_load_files()
        self.catalog.print_all_metadata()

    def load_tsp_files(self, directory_path: str) -> None:
        """
        Loads .tsp files from the selected directory using TSPCatalog.

        :param directory_path: The path to the directory containing TSP files.
        """
        self.catalog.load_files(directory_path)

    def start_simulated_annealing(self, distance_matrix: list[list[float]], temperature: float, iterations: int) -> None:
        """
        Starts the Simulated Annealing algorithm in a separate thread.

        :param distance_matrix: The distance matrix used by the algorithm.
        :param temperature: Initial temperature for Simulated Annealing.
        :param iterations: The maximum number of iterations to run.
        """
        if self.current_algorithm_thread is not None:
            print("An algorithm is already running.")
            return

        # Initialize the Simulated Annealing algorithm instance
        sa_instance = SimulatedAnnealing.SimulatedAnnealing(temperature, iterations, distance_matrix)

        # Initialize the thread for the Simulated Annealing algorithm
        self.current_algorithm_thread = SimulatedAnnealingThread(sa_instance)

        # Connect signals from the algorithm thread
        self.current_algorithm_thread.solution_signal.connect(self.update_current_solution)
        self.current_algorithm_thread.result_signal.connect(self.update_final_result)
        self.current_algorithm_thread.start()

    def update_current_solution(self, solution: list[float]) -> None:
        """
        Method called by the thread when a new current solution is provided.

        :param solution: The current solution provided by the algorithm.
        """
        print(f"Current solution: {solution}")

    def update_final_result(self, result: float) -> None:
        """
        Method called by the thread when the algorithm finishes and provides the final result.

        :param result: The final cost/result of the algorithm.
        """
        print(f"Final cost: {result}")

        # Reset the thread
        self.current_algorithm_thread = None

    def stop_current_algorithm(self) -> None:
        """
        Stops the currently running algorithm.
        """
        if self.current_algorithm_thread is not None:
            print("Stopping current algorithm...")
            self.current_algorithm_thread.terminate()
            self.current_algorithm_thread = None
