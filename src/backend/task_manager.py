# src/backend/task_manager.py
from PySide6.QtCore import QObject, Signal

from src.gui.components.directory_selector import DirectorySelector
from src.backend.components.tsplib_management.tsp_catalog import TSPCatalog
from src.backend.components.threads.algorithm_threads import SimulatedAnnealingThread

# Import modules generated by pybind11
import compiled_binaries.SimulatedAnnealing as SimulatedAnnealing


class TaskManager(QObject):
    solution_signal = Signal(list)  # Sygnał dla aktualnych rozwiązań
    result_signal = Signal(float)  # Sygnał dla wyniku końcowego

    def __init__(self) -> None:
        """
        Initializes the TaskManager, setting up the TSPLIB parser, catalog, and directory selector.
        """
        # Initialize TSPLIBParser and TSPCatalog
        super().__init__()
        self.catalog = TSPCatalog("resources/metadata/optimal_results.json")

        # Initialize DirectorySelector with injected TSPCatalog
        self.directory_selector = DirectorySelector(self.catalog)

        # Initialize algorithms, such as Simulated Annealing
        self.current_algorithm_thread = None

    def select_tsp_directory(self) -> None:
        """
        Invokes DirectorySelector to select a directory and automatically load TSP files.
        """
        self.directory_selector.select_directory_and_load_files()
        self.catalog.print_all_metadata()

    def get_loaded_file_names(self) -> list[str]:
        return [file.name for file in self.catalog.tsp_files]

    def load_tsp_files(self, directory_path: str) -> None:
        """
        Loads .tsp files from the selected directory using TSPCatalog.

        :param directory_path: The path to the directory containing TSP files.
        """
        self.catalog.load_files(directory_path)

    def start_simulated_annealing_for_file(self, file_name: str, temperature: float, iterations: int) -> None:
        """
        Starts the Simulated Annealing algorithm for a selected file in a separate thread.

        :param file_name: The name of the selected file.
        :param temperature: Initial temperature for Simulated Annealing.
        :param iterations: The maximum number of iterations to run.
        """
        if self.current_algorithm_thread is not None:
            print("An algorithm is already running.")
            return

        tsp_file = self.catalog.get_file_by_name(file_name)
        if tsp_file:
            if not tsp_file.has_loaded:
                tsp_file.load_distance_matrix()

            distance_matrix = tsp_file.get_distance_matrix()

            if distance_matrix:
                # Inicjalizacja instancji SA
                sa_instance = SimulatedAnnealing.SimulatedAnnealing(temperature, iterations, distance_matrix)

                # Utworzenie wątku
                self.current_algorithm_thread = SimulatedAnnealingThread(sa_instance)

                # Połączenie sygnałów wątku do sygnałów TaskManager
                self.current_algorithm_thread.solution_signal.connect(self.solution_signal.emit)
                self.current_algorithm_thread.result_signal.connect(self.result_signal.emit)

                # Uruchomienie wątku
                self.current_algorithm_thread.start()
            else:
                print("Distance matrix not available.")
        else:
            print("Selected file not found.")

    def update_current_solution(self, solution: list[float]) -> None:
        """
        Method called by the thread when a new current solution is provided.

        :param solution: The current solution provided by the algorithm.
        """
        print(f"Current solution: {solution}")

    def update_final_result(self, result: float) -> None:
        """
        Method called by the thread when the algorithm finishes and provides the final result.

        :param result: The final cost/result of the algorithm.
        """
        print(f"Final cost: {result}")

        # Reset the thread
        self.current_algorithm_thread = None

    def stop_current_algorithm(self) -> None:
        """
        Stops the currently running algorithm.
        """
        if self.current_algorithm_thread is not None:
            print("Stopping current algorithm...")
            self.current_algorithm_thread.terminate()
            self.current_algorithm_thread = None


    # def start_simulated_annealing(self, distance_matrix: list[list[float]], temperature: float, iterations: int) -> None:
    #     """
    #     Starts the Simulated Annealing algorithm in a separate thread.
    #
    #     :param distance_matrix: The distance matrix used by the algorithm.
    #     :param temperature: Initial temperature for Simulated Annealing.
    #     :param iterations: The maximum number of iterations to run.
    #     """
    #     if self.current_algorithm_thread is not None:
    #         print("An algorithm is already running.")
    #         return
    #
    #     # Initialize the Simulated Annealing algorithm instance
    #     sa_instance = SimulatedAnnealing.SimulatedAnnealing(temperature, iterations, distance_matrix)
    #
    #     # Initialize the thread for the Simulated Annealing algorithm
    #     self.current_algorithm_thread = SimulatedAnnealingThread(sa_instance)
    #
    #     # Connect signals from the algorithm thread
    #     self.current_algorithm_thread.solution_signal.connect(self.update_current_solution)
    #     self.current_algorithm_thread.result_signal.connect(self.update_final_result)
    #     self.current_algorithm_thread.start()